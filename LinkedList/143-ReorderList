// LeetCode #143
// Approach: Tortoise and Hare algorithm to find the mid
//           Reverse the later half and cut the list after the mid point
//           Interweave the two  
// Date: 20251108 

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    public ListNode middle(ListNode head) {
        //Fast and slow pointer point at head to begin with 
        ListNode fast = head;
        ListNode slow = head; 

        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;

    }

    public ListNode reverse(ListNode head) {
        ListNode curr = head;
        ListNode prev = null;

        //when curr = null (reached the end), it no longer has a pointer from the prev
        //element because the last element already points the prev element of itself 
        while (curr != null) {
            //save curr.next tempararily 
            ListNode temp = curr.next;
            //change the next pointer to prev 
            curr.next = prev; 

            //move curr pointer to the next element in the list 
            prev = curr;
            curr = temp; 
        }
        return prev;

    }
    public void reorderList(ListNode head) {
        ListNode mid = middle(head);

        //Reverse after the mid point
        // 1 -> 2 -> 3 <- 4 <- 5 
        //After finding the mid, we want to cut the list after mid
        // 1 -> 2 -> 3 -> null 
        // 4 -> 5 -> null
        // Then reverse the pointer 
        // null <- 4 <- 5 
        //So instead of last = reverse(mid), do reverse(mid.next)
        ListNode last = reverse(mid.next);
        //actually create the separate list to make the problem simplier 
        mid.next = null;

        while (head != null && last != null) {
            ListNode tempH = head.next;
            ListNode tempL = last.next;

            head.next = last;
            last.next = tempH;

            head = tempH;
            last = tempL;
        }
    }


}
