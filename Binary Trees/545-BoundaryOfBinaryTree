/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> boundaryOfBinaryTree(TreeNode root) {
      List<Integer> leftBoundary = new ArrayList<>();
      List<Integer> rightBoundary = new ArrayList<>();
      List<Integer> leaves = new ArrayList<>();
      List<Integer> res = new ArrayList<>();

      if (root.left == null && root.right == null) {
        res.add(root.val);
        return res;
      }

      left(root.left, leftBoundary);
      right(root.right, rightBoundary);
      leaves(root, leaves);

      res.add(root.val);
      res.addAll(leftBoundary);
      res.addAll(leaves);
      res.addAll(rightBoundary);

      return res; 
    }

    private void left(TreeNode node, List<Integer> leftBoundary) {
      if (node == null) return ; 
      if (node.left == null && node.right == null) return;
      
      //order matters 
      //add the node to the boundary list before the recursive calls to its children
      leftBoundary.add(node.val);

      if (node.left == null) left(node.right, leftBoundary);
      else left(node.left, leftBoundary);
    }

   private void right(TreeNode node, List<Integer> rightBoundary) {
      if (node == null) return ; 
      if (node.left == null && node.right == null) return;
      if (node.right == null) right(node.left, rightBoundary);
      else right(node.right, rightBoundary);

      //add AFTER recursion (we need bottom up)
      //add the val in reversing order by add(0, node.val) will cause 
      //O(n^2)
      rightBoundary.add(node.val);

    }

   private void leaves(TreeNode node, List<Integer> leaves) {
      if (node == null) return;
      if (node.left == null && node.right == null) {
         leaves.add(node.val);
         return;
      }

      leaves(node.left, leaves);
      leaves(node.right, leaves);

   }
}